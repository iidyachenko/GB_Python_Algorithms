"""
Задание 3.

Для этой задачи:
1) придумайте 1-3 решения (желательно хотя бы два)
2) оцените сложность каждого решения в нотации О-большое
3) сделайте вывод, какое решение эффективнее и почему

Примечание:
Без выполнения пунктов 2 и 3 задание считается нерешенным. Пункты 2 и 3 можно выполнить
через строки документации в самом коде.
Если у вас возникают сложности, постарайтесь подумать как можно решить задачу,
а не писать "мы это не проходили)".
Алгоритмизатор должен развивать мышление, а это прежде всего практика.
А без столкновения со сложностями его не развить.


Сама задача:
Имеется хранилище с информацией о компаниях: название и годовая прибыль.
Для реализации хранилища можно применить любой подход,
который вы придумаете, например, реализовать словарь.
Реализуйте поиск трех компаний с наибольшей годовой прибылью.
Выведите результат.
"""


def max_rev1(com):     # общая сложность O(n)
    max_num1, max_num2, max_num3 = 0, 0, 0   # 1
    max_txt1, max_txt2, max_txt3 = '', '', ''  # 1
    for key, value in com.items():  # n
        if value > max_num1:        # 1
            max_num3 = max_num2     # 1
            max_num2 = max_num1     # 1
            max_num1 = value        # 1
            max_txt3 = max_txt2     # 1
            max_txt2 = max_txt1     # 1
            max_txt1 = key          # 1
            continue
        if value > max_num2:        # 1
            max_num3 = max_num2     # 1
            max_num2 = value        # 1
            max_txt3 = max_num2     # 1
            max_txt2 = key          # 1
            continue
        if value > max_num3:        # 1
            max_num3 = value        # 1
            max_txt3 = key          # 1
            continue
    print(max_txt1, '', max_num1)   # 1
    print(max_txt2, '', max_num2)   # 1
    print(max_txt3, '', max_num3)   # 1


def max_rev2(com):  # общая сложность O(n Log n)
    list_com = list(com.items())    # n
    list_com.sort(key=lambda j: j[1])   # n Log n
    for i in range(1, 4):   # 4
        print(list_com[len(list_com) - i])  # 1

#  За счет использование сортировки сложность второго алгоритма будет на большом количестве n больше,
#  Однако он более гибкий и лаконичный хотя может проигрывать по быстродейсттвию


company = {'a': 900, 'b': 600, 'c': 200, 'd': 700, 'e': 100, 'f': 200, 'g': 500, 'h': 600, 'i': 300, 'm': 1000}
max_rev1(company)
max_rev2(company)
